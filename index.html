<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICT Closed Tickets Analytics Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        }
        
        body { 
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }
        
        .dashboard-container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .dashboard-header {
            background: linear-gradient(to right, #2c5282, #4a6fa5);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .dashboard-header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .dashboard-header p {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 25px;
            background: #f8fafc;
        }
        
        .stat-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 15px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }
        
        .stat-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        .stat-content h3 {
            font-size: 1.1rem;
            color: #64748b;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2c5282;
        }
        
        .stat-subtitle {
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
            padding: 25px;
        }
        
        .chart-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f1f5f9;
        }
        
        .chart-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c5282;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .chart-subtitle {
            color: #64748b;
            font-size: 0.95rem;
        }
        
        .chart-container {
            height: 300px;
            position: relative;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #f1f5f9;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            color: #64748b;
            text-align: center;
        }
        
        .loading-spinner {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #4a6fa5;
        }
        
        .error-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            color: #e53e3e;
            text-align: center;
        }
        
        .refresh-btn {
            background: #4a6fa5;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            margin-top: 20px;
            transition: background 0.3s;
        }
        
        .refresh-btn:hover {
            background: #2c5282;
        }
        
        .dashboard-footer {
            text-align: center;
            padding: 20px;
            color: #94a3b8;
            font-size: 0.9rem;
            border-top: 1px solid #e2e8f0;
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .dashboard-header h1 {
                font-size: 1.8rem;
            }
            
            .charts-container {
                padding: 15px;
            }
            
            .chart-card {
                padding: 15px;
            }
            
            .chart-container {
                height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="dashboard-header">
            <h1><i class="fas fa-chart-line"></i> ICT Closed Tickets Analytics Dashboard</h1>
            <p>Comprehensive analysis of resolved ICT service requests with insights into demographics, response times, and performance metrics</p>
        </div>
        
        <div class="stats-summary" id="statsSummary">
            <!-- Stats will be populated by JavaScript -->
        </div>
        
        <div class="charts-container">
            <!-- Chart 1: Demographics (Age & Gender) -->
            <div class="chart-card">
                <div class="chart-header">
                    <div>
                        <div class="chart-title"><i class="fas fa-users"></i> Demographics Overview</div>
                        <div class="chart-subtitle">Age distribution and sex breakdown of talent</div>
                    </div>
                </div>
                <div class="chart-container" id="demographicsChart"></div>
                <div class="legend" id="demographicsLegend"></div>
            </div>
            
            <!-- Chart 2: Regulation Area Distribution -->
            <div class="chart-card">
                <div class="chart-header">
                    <div>
                        <div class="chart-title"><i class="fas fa-sitemap"></i> Regulation Areas</div>
                        <div class="chart-subtitle">Distribution of tickets across regulation areas</div>
                    </div>
                </div>
                <div class="chart-container" id="regulationChart"></div>
                <div class="legend" id="regulationLegend"></div>
            </div>
            
            <!-- Chart 3: Problem Types -->
            <div class="chart-card">
                <div class="chart-header">
                    <div>
                        <div class="chart-title"><i class="fas fa-exclamation-triangle"></i> Problem Types Analysis</div>
                        <div class="chart-subtitle">Most common issues encountered by talent</div>
                    </div>
                </div>
                <div class="chart-container" id="problemChart"></div>
                <div class="legend" id="problemLegend"></div>
            </div>
            
            <!-- Chart 4: Response Time Performance (UPDATED) -->
            <div class="chart-card">
                <div class="chart-header">
                    <div>
                        <div class="chart-title"><i class="fas fa-stopwatch"></i> Response Time Analysis</div>
                        <div class="chart-subtitle">Distribution by response time categories</div>
                    </div>
                </div>
                <div class="chart-container" id="responseTimeChart"></div>
                <div class="legend" id="responseTimeLegend"></div>
            </div>
            
            <!-- Chart 5: Performance Ratings -->
            <div class="chart-card">
                <div class="chart-header">
                    <div>
                        <div class="chart-title"><i class="fas fa-star"></i> Performance Ratings</div>
                        <div class="chart-subtitle">Average performance ratings across different categories</div>
                    </div>
                </div>
                <div class="chart-container" id="performanceChart"></div>
                <div class="legend" id="performanceLegend"></div>
            </div>
            
            <!-- Chart 6: Correlation Analysis -->
            <div class="chart-card">
                <div class="chart-header">
                    <div>
                        <div class="chart-title"><i class="fas fa-project-diagram"></i> Correlation Analysis</div>
                        <div class="chart-subtitle">Response time vs. performance rating correlation</div>
                    </div>
                </div>
                <div class="chart-container" id="correlationChart"></div>
                <div class="legend" id="correlationLegend"></div>
            </div>
        </div>
        
        <div id="loading" class="loading">
            <div class="loading-spinner">
                <i class="fas fa-spinner fa-spin"></i>
            </div>
            <h2>Loading Closed Tickets Analytics</h2>
            <p>Fetching and analyzing data from Google Sheets...</p>
        </div>
        
        <div id="error" class="error-message" style="display: none;">
            <div style="font-size: 3rem; margin-bottom: 20px;">
                <i class="fas fa-exclamation-triangle"></i>
            </div>
            <h2>Unable to Load Analytics Data</h2>
            <p id="errorMessage">Please check your connection and try again.</p>
            <button class="refresh-btn" onclick="loadClosedTicketsData()">
                <i class="fas fa-redo-alt"></i> Try Again
            </button>
        </div>
        
        <div class="dashboard-footer">
            <p>Data Source: ICT Concerns - Closed Tickets Sheet | Last Updated: <span id="lastUpdated"></span></p>
            <p>Analytics Dashboard â€¢ Auto-refreshes every 10 minutes</p>
        </div>
    </div>

    <script>
        // Main data storage
        let closedTicketsData = [];
        let analyticsSummary = {};
        
        // Response time mapping - converts text categories to numeric values
        const responseTimeMapping = {
            // Text categories from K column to numeric hours
            'Less than one (1) hour': { numericValue: 0.5, label: 'Less than 1 hour', description: '<1 hr' },
            'Within the day': { numericValue: 4.5, label: 'Within the day', description: '1-8 hrs' },
            'The next day': { numericValue: 12, label: 'The next day', description: '8-16 hrs' },
            'More than two (2) days': { numericValue: 24, label: 'More than 2 days', description: '>16 hrs' },
            
            // Add variations just in case
            'Less than one hour': { numericValue: 0.5, label: 'Less than 1 hour', description: '<1 hr' },
            'Within the day (1-8 hrs)': { numericValue: 4.5, label: 'Within the day', description: '1-8 hrs' },
            'The next day (8-16 hrs)': { numericValue: 12, label: 'The next day', description: '8-16 hrs' },
            'More than 2 days': { numericValue: 24, label: 'More than 2 days', description: '>16 hrs' },
            'More than two days': { numericValue: 24, label: 'More than 2 days', description: '>16 hrs' }
        };
        
        // Color scales
        const colorScale = d3.scaleOrdinal()
            .range(['#4a6fa5', '#2c5282', '#38a169', '#d69e2e', '#e53e3e', '#805ad5', '#dd6b20', '#319795']);
        
        // Tooltip element
        const tooltip = d3.select('body').append('div')
            .attr('class', 'tooltip')
            .style('opacity', 0);
        
        // Function to convert response time text to numeric value
        function convertResponseTimeToNumeric(responseTimeText) {
            if (!responseTimeText) return 0;
            
            const normalizedText = responseTimeText.trim();
            
            // Try exact match first
            if (responseTimeMapping[normalizedText]) {
                return responseTimeMapping[normalizedText].numericValue;
            }
            
            // Try partial match
            for (const [key, value] of Object.entries(responseTimeMapping)) {
                if (normalizedText.toLowerCase().includes(key.toLowerCase())) {
                    return value.numericValue;
                }
            }
            
            // Default to 0 if no match found
            console.log('Unknown response time category:', normalizedText);
            return 0;
        }
        
        // Function to get response time category info
        function getResponseTimeCategoryInfo(responseTimeText) {
            if (!responseTimeText) return null;
            
            const normalizedText = responseTimeText.trim();
            
            // Try exact match first
            if (responseTimeMapping[normalizedText]) {
                return responseTimeMapping[normalizedText];
            }
            
            // Try partial match
            for (const [key, value] of Object.entries(responseTimeMapping)) {
                if (normalizedText.toLowerCase().includes(key.toLowerCase())) {
                    return value;
                }
            }
            
            return null;
        }
        
        // Load data from Google Sheets
        async function loadClosedTicketsData() {
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const statsSummary = document.getElementById('statsSummary');
            
            loading.style.display = 'flex';
            error.style.display = 'none';
            statsSummary.innerHTML = '';
            
            try {
                // Use CORS proxy for better compatibility
                const originalUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSlQLcK_Ktw2zemNHDZ_70giWPqT54Mvoci_dJxQz1RWYhe94UaDQLPQU89DUYLTY-ow7s2sWa-PB0h/pub?gid=1210338777&single=true&output=csv';
                const corsProxy = 'https://api.allorigins.win/raw?url=';
                const csvUrl = corsProxy + encodeURIComponent(originalUrl);
                
                console.log('Loading closed tickets from:', csvUrl);
                
                let response;
                try {
                    response = await fetch(csvUrl);
                } catch (proxyError) {
                    // Fall back to direct access if proxy fails
                    console.log('CORS proxy failed, trying direct access...');
                    response = await fetch(originalUrl);
                }
                
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const csvText = await response.text();
                
                // Parse CSV
                const rows = csvText.split('\n');
                closedTicketsData = [];
                
                // Parse and filter valid rows
                for (let i = 1; i < rows.length; i++) {
                    if (rows[i].trim() === '') continue;
                    
                    const cols = parseCSVRow(rows[i]);
                    
                    // Check if we have the required columns (A-M)
                    if (cols.length >= 13) {
                        // Get response time text from column K (index 10)
                        const responseTimeText = cols[10] || '';
                        
                        // Convert response time text to numeric value
                        const responseTimeNumeric = convertResponseTimeToNumeric(responseTimeText);
                        const responseTimeCategory = getResponseTimeCategoryInfo(responseTimeText);
                        
                        // Create ticket object with only the columns we need
                        const ticket = {
                            'Age': cols[3] || '',        // Column D
                            'Sex': cols[4] || '',        // Column E
                            'Regulation Area': cols[6] || '', // Column G
                            'Problem Encountered': cols[7] || '', // Column H
                            'Response Time Text': responseTimeText, // Column K (text)
                            'Response Time': responseTimeNumeric, // Converted numeric value
                            'Response Time Category': responseTimeCategory, // Category info
                            'Average Performance': parseFloat(cols[12]) || 0 // Column M
                        };
                        
                        // Only add if we have at least some valid data
                        if (ticket['Age'] || ticket['Sex'] || ticket['Regulation Area'] || 
                            ticket['Problem Encountered'] || ticket['Response Time'] > 0 || 
                            ticket['Average Performance'] > 0) {
                            closedTicketsData.push(ticket);
                        }
                    }
                }
                
                console.log('Loaded', closedTicketsData.length, 'closed tickets');
                console.log('Sample ticket:', closedTicketsData[0]);
                
                if (closedTicketsData.length > 0) {
                    // Analyze data
                    analyzeData();
                    
                    // Update last updated timestamp
                    document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
                    
                    // Hide loading, show charts
                    loading.style.display = 'none';
                    
                    // Create all visualizations
                    createSummaryStats();
                    createDemographicsChart();
                    createRegulationAreaChart();
                    createProblemTypeChart();
                    createResponseTimeChart();
                    createPerformanceChart();
                    createCorrelationChart();
                } else {
                    throw new Error('No valid closed ticket data found in sheet');
                }
                
            } catch (err) {
                console.error('Error loading closed tickets:', err);
                document.getElementById('errorMessage').textContent = err.message;
                loading.style.display = 'none';
                error.style.display = 'flex';
            }
        }
        
        // Parse CSV row with proper handling of quoted fields
        function parseCSVRow(row) {
            const cols = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    cols.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            cols.push(current.trim());
            return cols;
        }
        
        // Analyze the data to create summary statistics
        function analyzeData() {
            analyticsSummary = {
                totalTickets: closedTicketsData.length,
                
                // Age analysis
                ageGroups: {},
                averageAge: 0,
                
                // Gender analysis
                genderCount: { Male: 0, Female: 0 },
                
                // Regulation area analysis
                regulationAreas: {},
                
                // Problem type analysis
                problemTypes: {},
                
                // Response time analysis - categories from K column
                responseTimeCategories: {
                    'Less than 1 hour': { 
                        label: 'Less than 1 hour', 
                        description: '<1 hr',
                        count: 0,
                        numericValue: 0.5
                    },
                    'Within the day': { 
                        label: 'Within the day', 
                        description: '1-8 hrs',
                        count: 0,
                        numericValue: 4.5
                    },
                    'The next day': { 
                        label: 'The next day', 
                        description: '8-16 hrs',
                        count: 0,
                        numericValue: 12
                    },
                    'More than 2 days': { 
                        label: 'More than 2 days', 
                        description: '>16 hrs',
                        count: 0,
                        numericValue: 24
                    }
                },
                
                // Response time numeric stats
                responseTimeStats: {
                    min: Infinity,
                    max: 0,
                    avg: 0,
                    total: 0
                },
                
                // Performance analysis
                performanceStats: {
                    min: Infinity,
                    max: 0,
                    avg: 0,
                    total: 0
                }
            };
            
            let ageSum = 0;
            let validAgeCount = 0;
            let responseTimeSum = 0;
            let validResponseTimeCount = 0;
            let performanceSum = 0;
            let validPerformanceCount = 0;
            
            // Process each ticket
            closedTicketsData.forEach(ticket => {
                // Age analysis
                if (ticket.Age) {
                    const age = parseInt(ticket.Age);
                    if (!isNaN(age)) {
                        ageSum += age;
                        validAgeCount++;
                        
                        // Categorize into age groups
                        let ageGroup;
                        if (age <= 25) ageGroup = '18-25';
                        else if (age <= 35) ageGroup = '26-35';
                        else if (age <= 45) ageGroup = '36-45';
                        else if (age <= 55) ageGroup = '46-55';
                        else ageGroup = '56+';
                        
                        analyticsSummary.ageGroups[ageGroup] = (analyticsSummary.ageGroups[ageGroup] || 0) + 1;
                    }
                }
                
                // Gender analysis
                if (ticket.Sex) {
                    const gender = ticket.Sex.trim().toLowerCase();
                    if (gender === 'male' || gender === 'm') {
                        analyticsSummary.genderCount.Male++;
                    } else if (gender === 'female' || gender === 'f') {
                        analyticsSummary.genderCount.Female++;
                    }
                }
                
                // Regulation area analysis
                if (ticket['Regulation Area']) {
                    const area = ticket['Regulation Area'].trim();
                    analyticsSummary.regulationAreas[area] = (analyticsSummary.regulationAreas[area] || 0) + 1;
                }
                
                // Problem type analysis
                if (ticket['Problem Encountered']) {
                    const problem = ticket['Problem Encountered'].trim();
                    analyticsSummary.problemTypes[problem] = (analyticsSummary.problemTypes[problem] || 0) + 1;
                }
                
                // Response time analysis
                const responseTime = ticket['Response Time'];
                if (responseTime > 0) {
                    // Update category counts based on text category
                    const categoryInfo = ticket['Response Time Category'];
                    if (categoryInfo) {
                        if (categoryInfo.label === 'Less than 1 hour') {
                            analyticsSummary.responseTimeCategories['Less than 1 hour'].count++;
                        } else if (categoryInfo.label === 'Within the day') {
                            analyticsSummary.responseTimeCategories['Within the day'].count++;
                        } else if (categoryInfo.label === 'The next day') {
                            analyticsSummary.responseTimeCategories['The next day'].count++;
                        } else if (categoryInfo.label === 'More than 2 days') {
                            analyticsSummary.responseTimeCategories['More than 2 days'].count++;
                        }
                    }
                    
                    // Update numeric stats
                    responseTimeSum += responseTime;
                    validResponseTimeCount++;
                    
                    if (responseTime < analyticsSummary.responseTimeStats.min) {
                        analyticsSummary.responseTimeStats.min = responseTime;
                    }
                    if (responseTime > analyticsSummary.responseTimeStats.max) {
                        analyticsSummary.responseTimeStats.max = responseTime;
                    }
                }
                
                // Performance analysis
                if (ticket['Average Performance'] > 0) {
                    performanceSum += ticket['Average Performance'];
                    validPerformanceCount++;
                    
                    if (ticket['Average Performance'] < analyticsSummary.performanceStats.min) {
                        analyticsSummary.performanceStats.min = ticket['Average Performance'];
                    }
                    if (ticket['Average Performance'] > analyticsSummary.performanceStats.max) {
                        analyticsSummary.performanceStats.max = ticket['Average Performance'];
                    }
                }
            });
            
            // Calculate averages
            if (validAgeCount > 0) {
                analyticsSummary.averageAge = Math.round(ageSum / validAgeCount);
            }
            
            if (validResponseTimeCount > 0) {
                analyticsSummary.responseTimeStats.avg = responseTimeSum / validResponseTimeCount;
                analyticsSummary.responseTimeStats.total = responseTimeSum;
            }
            
            if (validPerformanceCount > 0) {
                analyticsSummary.performanceStats.avg = performanceSum / validPerformanceCount;
                analyticsSummary.performanceStats.total = performanceSum;
            }
            
            console.log('Analytics summary:', analyticsSummary);
        }
        
        // Create summary statistics cards
        function createSummaryStats() {
            const statsSummary = document.getElementById('statsSummary');
            
            // Calculate response time category percentages
            const responseCategories = analyticsSummary.responseTimeCategories;
            const totalWithResponseTime = 
                responseCategories['Less than 1 hour'].count +
                responseCategories['Within the day'].count +
                responseCategories['The next day'].count +
                responseCategories['More than 2 days'].count;
            
            // Find the most common response time category
            const categoryArray = Object.values(responseCategories);
            const mostCommonCategory = categoryArray.reduce((prev, current) => 
                (prev.count > current.count) ? prev : current
            );
            
            // Calculate percentage of tickets resolved in less than 1 hour
            const lessThan1HourPercentage = totalWithResponseTime > 0 ? 
                Math.round((responseCategories['Less than 1 hour'].count / totalWithResponseTime) * 100) : 0;
            
            const statsCards = [
                {
                    icon: 'fas fa-ticket-alt',
                    iconColor: '#4a6fa5',
                    title: 'Total Closed Tickets',
                    value: analyticsSummary.totalTickets,
                    subtitle: 'Successfully resolved requests'
                },
                {
                    icon: 'fas fa-user-friends',
                    iconColor: '#38a169',
                    title: 'Average Age',
                    value: analyticsSummary.averageAge,
                    subtitle: 'Years'
                },
                {
                    icon: 'fas fa-venus-mars',
                    iconColor: '#d53f8c',
                    title: 'Sex Ratio',
                    value: `${analyticsSummary.genderCount.Male}:${analyticsSummary.genderCount.Female}`,
                    subtitle: 'Male:Female'
                },
                {
                    icon: 'fas fa-bolt',
                    iconColor: '#38a169',
                    title: 'Most Common Response',
                    value: mostCommonCategory.label.split(' ')[0],
                    subtitle: `${mostCommonCategory.count} tickets`
                },
                {
                    icon: 'fas fa-star',
                    iconColor: '#e53e3e',
                    title: 'Avg Performance',
                    value: analyticsSummary.performanceStats.avg.toFixed(1),
                    subtitle: 'Out of 5'
                },
                {
                    icon: 'fas fa-percentage',
                    iconColor: '#4a6fa5',
                    title: '<1 Hour Response Rate',
                    value: `${lessThan1HourPercentage}%`,
                    subtitle: 'Immediate resolution'
                }
            ];
            
            statsSummary.innerHTML = statsCards.map(card => `
                <div class="stat-card">
                    <div class="stat-icon" style="background-color: ${card.iconColor}20; color: ${card.iconColor};">
                        <i class="${card.icon}"></i>
                    </div>
                    <div class="stat-content">
                        <h3>${card.title}</h3>
                        <div class="stat-value">${card.value}</div>
                        <div class="stat-subtitle">${card.subtitle}</div>
                    </div>
                </div>
            `).join('');
        }
        
        // Create demographics chart (age groups and gender) - OPTION 1: Grouped Bar Chart
        function createDemographicsChart() {
            const container = document.getElementById('demographicsChart');
            container.innerHTML = '';
            const legend = document.getElementById('demographicsLegend');
            legend.innerHTML = '';
            
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#demographicsChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Prepare combined age and gender data
            const ageGenderData = {};
            
            closedTicketsData.forEach(ticket => {
                if (ticket.Age && ticket.Sex) {
                    const age = parseInt(ticket.Age);
                    if (!isNaN(age)) {
                        let ageGroup;
                        if (age <= 25) ageGroup = '18-25';
                        else if (age <= 35) ageGroup = '26-35';
                        else if (age <= 45) ageGroup = '36-45';
                        else if (age <= 55) ageGroup = '46-55';
                        else ageGroup = '56+';
                        
                        const gender = ticket.Sex.trim().toLowerCase();
                        const genderKey = (gender === 'male' || gender === 'm') ? 'Male' : 
                                         (gender === 'female' || gender === 'f') ? 'Female' : 'Other';
                        
                        if (!ageGenderData[ageGroup]) {
                            ageGenderData[ageGroup] = { 'Male': 0, 'Female': 0, 'Other': 0 };
                        }
                        
                        ageGenderData[ageGroup][genderKey] += 1;
                    }
                }
            });
            
            // Convert to array format for d3
            const ageGroups = Object.keys(ageGenderData).sort();
            const genders = ['Male', 'Female'];
            
            const data = [];
            ageGroups.forEach(ageGroup => {
                genders.forEach(gender => {
                    if (ageGenderData[ageGroup][gender] > 0) {
                        data.push({
                            ageGroup: ageGroup,
                            gender: gender,
                            count: ageGenderData[ageGroup][gender]
                        });
                    }
                });
            });
            
            // X scale for age groups
            const x0 = d3.scaleBand()
                .domain(ageGroups)
                .range([0, width])
                .padding(0.2);
            
            // X scale for genders within each age group
            const x1 = d3.scaleBand()
                .domain(genders)
                .range([0, x0.bandwidth()])
                .padding(0.05);
            
            // Y scale for counts
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.count)])
                .nice()
                .range([height, 0]);
            
            // Gender colors
            const genderColors = {
                'Male': '#2c5282',
                'Female': '#d53f8c',
                'Other': '#94a3b8'
            };
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0));
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add bars for each age group and gender
            const ageGroupsSelection = svg.selectAll('.age-group')
                .data(ageGroups)
                .enter()
                .append('g')
                .attr('class', 'age-group')
                .attr('transform', d => `translate(${x0(d)},0)`);
            
            ageGroupsSelection.selectAll('.gender-bar')
                .data(d => genders.map(gender => ({
                    ageGroup: d,
                    gender: gender,
                    count: ageGenderData[d][gender] || 0
                })))
                .enter()
                .append('rect')
                .attr('class', 'gender-bar')
                .attr('x', d => x1(d.gender))
                .attr('y', d => y(d.count))
                .attr('width', x1.bandwidth())
                .attr('height', d => height - y(d.count))
                .attr('fill', d => genderColors[d.gender])
                .attr('rx', 3)
                .attr('ry', 3)
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', .9);
                    tooltip.html(`
                        <strong>${d.ageGroup} Age Group</strong><br/>
                        Gender: ${d.gender}<br/>
                        Tickets: ${d.count}<br/>
                        Percentage: ${((d.count / analyticsSummary.totalTickets) * 100).toFixed(1)}%
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(500).style('opacity', 0);
                });
            
            // Add value labels on bars (only if count > 0 and bar is tall enough)
            ageGroupsSelection.selectAll('.gender-label')
                .data(d => genders.map(gender => ({
                    ageGroup: d,
                    gender: gender,
                    count: ageGenderData[d][gender] || 0
                })))
                .enter()
                .append('text')
                .filter(d => d.count > 0 && (height - y(d.count)) > 20) // Only show if bar is tall enough
                .attr('class', 'gender-label')
                .attr('x', d => x1(d.gender) + x1.bandwidth() / 2)
                .attr('y', d => y(d.count) - 5)
                .attr('text-anchor', 'middle')
                .text(d => d.count)
                .style('font-size', '11px')
                .style('font-weight', 'bold')
                .style('fill', d => d.gender === 'Female' ? '#d53f8c' : '#2c5282');
            
            // Add X axis label
            svg.append('text')
                .attr('transform', `translate(${width/2},${height + margin.bottom - 10})`)
                .style('text-anchor', 'middle')
                .text('Age Group')
                .style('fill', '#64748b');
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Number of Tickets')
                .style('fill', '#64748b');
            
            // Create legend for gender
            const genderData = [
                { label: 'Male', count: analyticsSummary.genderCount.Male, color: '#2c5282' },
                { label: 'Female', count: analyticsSummary.genderCount.Female, color: '#d53f8c' }
            ];
            
            legend.innerHTML = genderData.map(item => {
                const percentage = ((item.count / analyticsSummary.totalTickets) * 100).toFixed(1);
                return `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${item.color};"></div>
                        <span>${item.label}: ${item.count} tickets (${percentage}%)</span>
                    </div>
                `;
            }).join('');
        }
        
        // Create regulation area chart (pie chart)
        function createRegulationAreaChart() {
            const container = document.getElementById('regulationChart');
            container.innerHTML = '';
            const legend = document.getElementById('regulationLegend');
            legend.innerHTML = '';
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            const radius = Math.min(width, height) / 2 - 20;
            
            const svg = d3.select('#regulationChart')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${width/2},${height/2})`);
            
            // Prepare regulation area data
            const regulationData = Object.entries(analyticsSummary.regulationAreas)
                .map(([area, count]) => ({ area, count }))
                .sort((a, b) => b.count - a.count);
            
            // Limit to top 8 areas for readability
            const topRegulations = regulationData.slice(0, 8);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.count)
                .sort(null);
            
            // Create arc generator
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);
            
            // Create outer arc for labels
            const outerArc = d3.arc()
                .innerRadius(radius * 1.1)
                .outerRadius(radius * 1.1);
            
            // Generate arcs
            const arcs = pie(topRegulations);
            
            // Color scale for regulation areas
            const regulationColor = d3.scaleOrdinal()
                .domain(topRegulations.map(d => d.area))
                .range(colorScale.range());
            
            // Draw arcs
            svg.selectAll('path')
                .data(arcs)
                .enter()
                .append('path')
                .attr('d', arc)
                .attr('fill', d => regulationColor(d.data.area))
                .attr('stroke', 'white')
                .style('stroke-width', '2px')
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', .9);
                    tooltip.html(`
                        <strong>${d.data.area}</strong><br/>
                        Tickets: ${d.data.count}<br/>
                        Percentage: ${((d.data.count / analyticsSummary.totalTickets) * 100).toFixed(1)}%
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                    
                    d3.select(this).transition()
                        .duration(200)
                        .attr('transform', 'scale(1.05)');
                })
                .on('mouseout', function(event, d) {
                    tooltip.transition().duration(500).style('opacity', 0);
                    d3.select(this).transition()
                        .duration(200)
                        .attr('transform', 'scale(1)');
                });
            
            // Add labels
            svg.selectAll('text')
                .data(arcs)
                .enter()
                .append('text')
                .attr('transform', d => {
                    const pos = outerArc.centroid(d);
                    return `translate(${pos[0]},${pos[1]})`;
                })
                .attr('dy', '.35em')
                .style('text-anchor', d => {
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                    return (midangle < Math.PI) ? 'start' : 'end';
                })
                .text(d => d.data.area)
                .style('font-size', '12px')
                .style('fill', '#2c5282')
                .style('font-weight', 'bold');
            
            // Create legend
            legend.innerHTML = topRegulations.map((item, i) => `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${regulationColor(item.area)};"></div>
                    <span>${item.area}: ${item.count}</span>
                </div>
            `).join('');
        }
        
        // Create problem type chart (horizontal bar chart)
        function createProblemTypeChart() {
            const container = document.getElementById('problemChart');
            container.innerHTML = '';
            const legend = document.getElementById('problemLegend');
            legend.innerHTML = '';
            
            const margin = { top: 20, right: 30, bottom: 40, left: 150 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#problemChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Prepare problem type data
            const problemData = Object.entries(analyticsSummary.problemTypes)
                .map(([problem, count]) => ({ problem, count }))
                .sort((a, b) => b.count - a.count);
            
            // Limit to top 10 problems for readability
            const topProblems = problemData.slice(0, 10);
            
            // Y scale for problems
            const y = d3.scaleBand()
                .domain(topProblems.map(d => d.problem))
                .range([0, height])
                .padding(0.2);
            
            // X scale for counts
            const x = d3.scaleLinear()
                .domain([0, d3.max(topProblems, d => d.count)])
                .nice()
                .range([0, width]);
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));
            
            // Add bars
            svg.selectAll('.problem-bar')
                .data(topProblems)
                .enter()
                .append('rect')
                .attr('class', 'problem-bar')
                .attr('x', 0)
                .attr('y', d => y(d.problem))
                .attr('width', d => x(d.count))
                .attr('height', y.bandwidth())
                .attr('fill', (d, i) => colorScale(i))
                .attr('rx', 4)
                .attr('ry', 4)
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', .9);
                    tooltip.html(`
                        <strong>${d.problem}</strong><br/>
                        Tickets: ${d.count}<br/>
                        Percentage: ${((d.count / analyticsSummary.totalTickets) * 100).toFixed(1)}%
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(500).style('opacity', 0);
                });
            
            // Add value labels on bars
            svg.selectAll('.problem-label')
                .data(topProblems)
                .enter()
                .append('text')
                .attr('class', 'problem-label')
                .attr('x', d => x(d.count) + 5)
                .attr('y', d => y(d.problem) + y.bandwidth() / 2)
                .attr('dy', '.35em')
                .text(d => d.count)
                .style('font-weight', 'bold')
                .style('fill', '#2c5282');
            
            // Add X axis label
            svg.append('text')
                .attr('transform', `translate(${width/2},${height + margin.bottom - 10})`)
                .style('text-anchor', 'middle')
                .text('Number of Tickets')
                .style('fill', '#64748b');
            
            // Add chart title inside
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#4a6fa5')
                .text('Top 10 Most Common Problems');
            
            // Create legend
            legend.innerHTML = `<div class="legend-item">
                <span>Showing top 10 most common problems out of ${Object.keys(analyticsSummary.problemTypes).length} unique problem types</span>
            </div>`;
        }
        
        // UPDATED: Create response time chart with text categories from K column
        function createResponseTimeChart() {
            const container = document.getElementById('responseTimeChart');
            container.innerHTML = '';
            const legend = document.getElementById('responseTimeLegend');
            legend.innerHTML = '';
            
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#responseTimeChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Prepare response time category data from analytics
            const responseTimeData = [
                analyticsSummary.responseTimeCategories['Less than 1 hour'],
                analyticsSummary.responseTimeCategories['Within the day'],
                analyticsSummary.responseTimeCategories['The next day'],
                analyticsSummary.responseTimeCategories['More than 2 days']
            ];
            
            // Category colors
            const categoryColors = {
                'Less than 1 hour': '#38a169', // Green
                'Within the day': '#d69e2e',   // Yellow
                'The next day': '#ed8936',     // Orange
                'More than 2 days': '#e53e3e'  // Red
            };
            
            // X scale for categories (using descriptions)
            const x = d3.scaleBand()
                .domain(responseTimeData.map(d => d.description))
                .range([0, width])
                .padding(0.3);
            
            // Y scale for counts
            const y = d3.scaleLinear()
                .domain([0, d3.max(responseTimeData, d => d.count)])
                .nice()
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add bars
            svg.selectAll('.response-bar')
                .data(responseTimeData)
                .enter()
                .append('rect')
                .attr('class', 'response-bar')
                .attr('x', d => x(d.description))
                .attr('y', d => y(d.count))
                .attr('width', x.bandwidth())
                .attr('height', d => height - y(d.count))
                .attr('fill', d => categoryColors[d.label])
                .attr('rx', 4)
                .attr('ry', 4)
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', .9);
                    tooltip.html(`
                        <strong>${d.label}</strong><br/>
                        Time Range: ${d.description}<br/>
                        Tickets: ${d.count}<br/>
                        Percentage: ${calculateResponseTimePercentage(d.label)}%
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(500).style('opacity', 0);
                });
            
            // Add value labels on bars
            svg.selectAll('.response-label')
                .data(responseTimeData)
                .enter()
                .append('text')
                .attr('class', 'response-label')
                .attr('x', d => x(d.description) + x.bandwidth() / 2)
                .attr('y', d => y(d.count) - 5)
                .attr('text-anchor', 'middle')
                .text(d => d.count)
                .style('font-weight', 'bold')
                .style('fill', '#2c5282');
            
            // Calculate total tickets with response time
            const totalResponseTickets = responseTimeData.reduce((sum, d) => sum + d.count, 0);
            
            // Calculate average numeric response time for reference line
            const avgResponseTime = analyticsSummary.responseTimeStats.avg;
            
            // Add average response time line (if we have data)
            if (totalResponseTickets > 0 && avgResponseTime > 0) {
                svg.append('line')
                    .attr('x1', 0)
                    .attr('x2', width)
                    .attr('y1', y(avgResponseTime))
                    .attr('y2', y(avgResponseTime))
                    .attr('stroke', '#2c5282')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                // Add average label
                svg.append('text')
                    .attr('x', width - 5)
                    .attr('y', y(avgResponseTime) - 5)
                    .text(`Avg: ${avgResponseTime.toFixed(1)}h`)
                    .style('font-size', '12px')
                    .style('fill', '#2c5282')
                    .style('font-weight', 'bold')
                    .style('text-anchor', 'end');
            }
            
            // Add X axis label
            svg.append('text')
                .attr('transform', `translate(${width/2},${height + margin.bottom - 10})`)
                .style('text-anchor', 'middle')
                .text('Response Time Categories')
                .style('fill', '#64748b');
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Number of Tickets')
                .style('fill', '#64748b');
            
            // Add chart title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#4a6fa5')
                .text('Response Time Distribution by Category');
            
            // Calculate percentages for legend
            function calculateResponseTimePercentage(categoryLabel) {
                const category = responseTimeData.find(d => d.label === categoryLabel);
                if (!category || totalResponseTickets === 0) return 0;
                return ((category.count / totalResponseTickets) * 100).toFixed(1);
            }
            
            // Create detailed legend
            legend.innerHTML = responseTimeData.map(category => {
                const percentage = calculateResponseTimePercentage(category.label);
                return `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${categoryColors[category.label]};"></div>
                        <span>${category.label} (${category.description}): ${category.count} tickets (${percentage}%)</span>
                    </div>
                `;
            }).join('');
            
            // Add average to legend (if available)
            if (totalResponseTickets > 0 && avgResponseTime > 0) {
                legend.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2c5282; height: 2px; margin-top: 7px;"></div>
                        <span>Average Numeric Time: ${avgResponseTime.toFixed(1)} hours</span>
                    </div>
                `;
            }
        }
        
        // Create performance chart
        function createPerformanceChart() {
            const container = document.getElementById('performanceChart');
            container.innerHTML = '';
            const legend = document.getElementById('performanceLegend');
            legend.innerHTML = '';
            
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#performanceChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Group performance by rating (rounded to nearest 0.5)
            const performanceGroups = {};
            closedTicketsData.forEach(ticket => {
                if (ticket['Average Performance'] > 0) {
                    const rating = Math.round(ticket['Average Performance'] * 2) / 2; // Round to nearest 0.5
                    if (!performanceGroups[rating]) {
                        performanceGroups[rating] = [];
                    }
                    performanceGroups[rating].push(ticket);
                }
            });
            
            // Convert to array
            const performanceData = Object.entries(performanceGroups)
                .map(([rating, tickets]) => ({
                    rating: parseFloat(rating),
                    count: tickets.length,
                    tickets: tickets
                }))
                .sort((a, b) => a.rating - b.rating);
            
            // X scale for ratings
            const x = d3.scaleBand()
                .domain(performanceData.map(d => d.rating))
                .range([0, width])
                .padding(0.2);
            
            // Y scale for counts
            const y = d3.scaleLinear()
                .domain([0, d3.max(performanceData, d => d.count)])
                .nice()
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => d.toFixed(1)));
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add bars
            svg.selectAll('.performance-bar')
                .data(performanceData)
                .enter()
                .append('rect')
                .attr('class', 'performance-bar')
                .attr('x', d => x(d.rating))
                .attr('y', d => y(d.count))
                .attr('width', x.bandwidth())
                .attr('height', d => height - y(d.count))
                .attr('fill', d => {
                    // Color based on rating (green for high, yellow for medium, red for low)
                    if (d.rating >= 4) return '#38a169';
                    if (d.rating >= 3) return '#d69e2e';
                    return '#e53e3e';
                })
                .attr('rx', 4)
                .attr('ry', 4)
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', .9);
                    tooltip.html(`
                        <strong>Rating: ${d.rating}/5</strong><br/>
                        Tickets: ${d.count}<br/>
                        Percentage: ${((d.count / analyticsSummary.totalTickets) * 100).toFixed(1)}%
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(500).style('opacity', 0);
                });
            
            // Add value labels on bars
            svg.selectAll('.performance-label')
                .data(performanceData)
                .enter()
                .append('text')
                .attr('class', 'performance-label')
                .attr('x', d => x(d.rating) + x.bandwidth() / 2)
                .attr('y', d => y(d.count) - 5)
                .attr('text-anchor', 'middle')
                .text(d => d.count)
                .style('font-weight', 'bold')
                .style('fill', '#2c5282');
            
            // Add average line
            const avgPerformance = analyticsSummary.performanceStats.avg;
            svg.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(avgPerformance))
                .attr('y2', y(avgPerformance))
                .attr('stroke', '#2c5282')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');
            
            // Add average label
            svg.append('text')
                .attr('x', width - 5)
                .attr('y', y(avgPerformance) - 5)
                .text(`Avg: ${avgPerformance.toFixed(1)}`)
                .style('font-size', '12px')
                .style('fill', '#2c5282')
                .style('font-weight', 'bold')
                .style('text-anchor', 'end');
            
            // Add X axis label
            svg.append('text')
                .attr('transform', `translate(${width/2},${height + margin.bottom - 10})`)
                .style('text-anchor', 'middle')
                .text('Performance Rating (1-5 scale)')
                .style('fill', '#64748b');
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Number of Tickets')
                .style('fill', '#64748b');
            
            // Create legend
            legend.innerHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #38a169;"></div>
                    <span>High Performance (4.0+)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #d69e2e;"></div>
                    <span>Medium Performance (3.0-3.9)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e53e3e;"></div>
                    <span>Low Performance (&lt;3.0)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2c5282; height: 2px; margin-top: 7px;"></div>
                    <span>Average: ${avgPerformance.toFixed(1)}/5</span>
                </div>
            `;
        }
        
        // Create correlation chart (scatter plot)
        function createCorrelationChart() {
            const container = document.getElementById('correlationChart');
            container.innerHTML = '';
            const legend = document.getElementById('correlationLegend');
            legend.innerHTML = '';
            
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#correlationChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Prepare correlation data
            const correlationData = closedTicketsData
                .filter(ticket => ticket['Response Time'] > 0 && ticket['Average Performance'] > 0)
                .map(ticket => ({
                    responseTime: ticket['Response Time'],
                    performance: ticket['Average Performance'],
                    regulationArea: ticket['Regulation Area'] || 'Unknown'
                }));
            
            // X scale for response time
            const x = d3.scaleLinear()
                .domain([0, d3.max(correlationData, d => d.responseTime)])
                .nice()
                .range([0, width]);
            
            // Y scale for performance
            const y = d3.scaleLinear()
                .domain([0, 5]) // Performance is 1-5 scale
                .nice()
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => d + 'h'));
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickSize(-height).tickFormat(''));
            
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Add dots
            svg.selectAll('.correlation-dot')
                .data(correlationData)
                .enter()
                .append('circle')
                .attr('class', 'correlation-dot')
                .attr('cx', d => x(d.responseTime))
                .attr('cy', d => y(d.performance))
                .attr('r', 6)
                .attr('fill', d => {
                    // Color by response time category
                    if (d.responseTime < 1) return '#38a169';        // <1 hour
                    if (d.responseTime <= 8) return '#d69e2e';      // 1-8 hours
                    if (d.responseTime <= 16) return '#ed8936';     // 8-16 hours
                    return '#e53e3e';                              // >16 hours
                })
                .attr('opacity', 0.7)
                .attr('stroke', 'white')
                .attr('stroke-width', 1)
                .on('mouseover', function(event, d) {
                    tooltip.transition().duration(200).style('opacity', .9);
                    tooltip.html(`
                        <strong>Regulation Area: ${d.regulationArea}</strong><br/>
                        Response Time: ${d.responseTime.toFixed(1)} hours<br/>
                        Performance: ${d.performance.toFixed(1)}/5
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.transition().duration(500).style('opacity', 0);
                });
            
            // Calculate correlation coefficient
            const correlation = calculateCorrelation(correlationData);
            
            // Add correlation line if there's a correlation
            if (Math.abs(correlation) > 0.1 && correlationData.length > 1) {
                const regression = linearRegression(correlationData);
                
                svg.append('line')
                    .attr('x1', x(0))
                    .attr('x2', x(d3.max(correlationData, d => d.responseTime)))
                    .attr('y1', y(regression.intercept))
                    .attr('y2', y(regression.intercept + regression.slope * d3.max(correlationData, d => d.responseTime)))
                    .attr('stroke', '#2c5282')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
            }
            
            // Add X axis label
            svg.append('text')
                .attr('transform', `translate(${width/2},${height + margin.bottom - 10})`)
                .style('text-anchor', 'middle')
                .text('Response Time (hours)')
                .style('fill', '#64748b');
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Performance Rating (1-5)')
                .style('fill', '#64748b');
            
            // Add correlation coefficient text
            svg.append('text')
                .attr('x', width - 10)
                .attr('y', 20)
                .text(`Correlation: ${correlation.toFixed(2)}`)
                .style('font-size', '14px')
                .style('fill', '#2c5282')
                .style('font-weight', 'bold')
                .style('text-anchor', 'end');
            
            // Add response time category legend
            const responseColors = [
                { label: '<1 hour', color: '#38a169' },
                { label: '1-8 hours', color: '#d69e2e' },
                { label: '8-16 hours', color: '#ed8936' },
                { label: '>16 hours', color: '#e53e3e' }
            ];
            
            const colorLegend = responseColors.map(item => `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${item.color};"></div>
                    <span>${item.label}</span>
                </div>
            `).join('');
            
            // Create legend
            legend.innerHTML = `
                <div class="legend-item">
                    <span>Each dot represents one closed ticket</span>
                </div>
                ${colorLegend}
                <div class="legend-item">
                    <span>Correlation coefficient: ${correlation.toFixed(2)}</span>
                </div>
                ${Math.abs(correlation) > 0.1 && correlationData.length > 1 ? `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2c5282; height: 2px; margin-top: 7px;"></div>
                    <span>Regression line (trend)</span>
                </div>
                ` : ''}
            `;
        }
        
        // Helper function to calculate correlation coefficient
        function calculateCorrelation(data) {
            if (data.length < 2) return 0;
            
            const n = data.length;
            const sumX = data.reduce((sum, d) => sum + d.responseTime, 0);
            const sumY = data.reduce((sum, d) => sum + d.performance, 0);
            const sumXY = data.reduce((sum, d) => sum + d.responseTime * d.performance, 0);
            const sumX2 = data.reduce((sum, d) => sum + d.responseTime * d.responseTime, 0);
            const sumY2 = data.reduce((sum, d) => sum + d.performance * d.performance, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }
        
        // Helper function for linear regression
        function linearRegression(data) {
            const n = data.length;
            const sumX = data.reduce((sum, d) => sum + d.responseTime, 0);
            const sumY = data.reduce((sum, d) => sum + d.performance, 0);
            const sumXY = data.reduce((sum, d) => sum + d.responseTime * d.performance, 0);
            const sumX2 = data.reduce((sum, d) => sum + d.responseTime * d.responseTime, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', function() {
            loadClosedTicketsData();
            
            // Auto-refresh every 10 minutes
            setInterval(loadClosedTicketsData, 10 * 60 * 1000);
        });
    </script>
</body>
</html>
